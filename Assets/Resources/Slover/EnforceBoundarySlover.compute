#include "../Common.hlsl"

#pragma enable_d3d11_debug_symbols
#pragma kernel solveBoundary

Texture3D<float> SignedDistance_R;

StructuredBuffer<uint> TargetParticleIndirectArgment_R;

RWStructuredBuffer<float3> TargetParticlePosition_RW;
RWStructuredBuffer<float3> TargetParticleVelocity_RW;

SamplerState Sampler_Trilinear_Clamp_SignedDistance;

uniform float3 SDFDomainMin;
uniform float3 SDFCellSize;
uniform uint3 SDFResolution;

uniform float3 Translate;
uniform float3 Scale;
uniform float4x4 Rotation;
uniform float4x4 InvRotation;

uniform float3 BoundaryVel;

float3 estimateNormal(float3 p)
{
    const float h = 1.0f / (float3) SDFResolution; // replace by an appropriate value
    float Left = SignedDistance_R.SampleLevel(Sampler_Trilinear_Clamp_SignedDistance, p + float3(-h, 0, 0), 0);
    float Right = SignedDistance_R.SampleLevel(Sampler_Trilinear_Clamp_SignedDistance, p + float3(h, 0, 0), 0);
    float Down = SignedDistance_R.SampleLevel(Sampler_Trilinear_Clamp_SignedDistance, p + float3(0, -h, 0), 0);
    float Up = SignedDistance_R.SampleLevel(Sampler_Trilinear_Clamp_SignedDistance, p + float3(0, h, 0), 0);
    float Back = SignedDistance_R.SampleLevel(Sampler_Trilinear_Clamp_SignedDistance, p + float3(0, 0, -h), 0);
    float Front = SignedDistance_R.SampleLevel(Sampler_Trilinear_Clamp_SignedDistance, p + float3(0, 0, h), 0);
    return normalize(float3(Right - Left, Up - Down, Front - Back));
}

[numthreads(SPH_THREAD_NUM, 1, 1)]
void solveBoundary(uint ThreadIdx : SV_GroupIndex, uint GroupIdx : SV_GroupID)
{
    uint i = ThreadIdx + GroupIdx * SPH_THREAD_NUM;
    if (i >= TargetParticleIndirectArgment_R[ParticleCountArgumentOffset])
        return;
    
    float3 Pos = TargetParticlePosition_RW[i];
    float3 ObjectPos = mul(InvRotation, float4((Pos - Translate) / Scale, 1.0f)).xyz;
    
    //texture boundary info
    float3 Offset = ObjectPos - SDFDomainMin;
    float3 UVCoord = Offset / SDFCellSize / (float3) SDFResolution;
    float Dist = SignedDistance_R.SampleLevel(Sampler_Trilinear_Clamp_SignedDistance, UVCoord, 0);
    float3 Normal = normalize(estimateNormal(UVCoord));
    
    Normal = mul(Rotation, float4(Normal, 1.0f)).xyz;
    
    //apply Boundary effect
    if (Dist <= 0.0f)
    {
        float3 Vel = TargetParticleVelocity_RW[i];
        float3 RelativeVel = Vel - BoundaryVel;
        float NDotRelVel = dot(Normal, RelativeVel);
        float3 NorVel = NDotRelVel * Normal;
        float3 TanVel = RelativeVel - NorVel;
        if (NDotRelVel < 0.0f)
        {
            float R = 0.1f;
            float Mu = 0.1f;
            float3 DeltaNorVel = (-R - 1.0f) * NorVel;
            float LengthT = length(TanVel);
            if (LengthT > 0.0f)
            {
                double FrictionScale = max(1.0f - Mu * length(DeltaNorVel) / LengthT, 0.0f);
                TanVel *= FrictionScale * 0.1f;
            }
            NorVel = -R * NorVel;
            TargetParticleVelocity_RW[i] = NorVel + TanVel + BoundaryVel;
        }
        TargetParticlePosition_RW[i] = Pos - Dist * Normal;
    }
}