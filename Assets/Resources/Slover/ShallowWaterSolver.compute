#include "../Common.hlsl"

#pragma enable_d3d11_debug_symbols
#pragma kernel FluxComputation
#pragma kernel FluxApply

#define ThreadGroupX 32
#define ThreadGroupY 32
#define NUMTHREADS numthreads(ThreadGroupX, ThreadGroupY, 1)

// Sampling macro, just to simplify the code a bit
#define SAMPLE_WITH_OFFSET(tex, x, y) ((tex[id.xy + uint2(x, y)]))
#define CURRENT_SAMPLE(tex) (tex[id.xy])
#define LEFT_SAMPLE(tex) (SAMPLE_WITH_OFFSET(tex, -1, 0))
#define RIGHT_SAMPLE(tex) (SAMPLE_WITH_OFFSET(tex, 1, 0))
#define TOP_SAMPLE(tex) (SAMPLE_WITH_OFFSET(tex, 0, 1))
#define BOTTOM_SAMPLE(tex) (SAMPLE_WITH_OFFSET(tex, 0, -1))

// Directional maps channel semantics
#define LDIR(col) (col.r)
#define RDIR(col) (col.g)
#define TDIR(col) (col.b)
#define BDIR(col) (col.a)

// State channel semantics
#define TERRAIN_HEIGHT(col) (col.r)
#define WATER_HEIGHT(col) (col.g)
#define SEDIMENT(col) (col.b)
#define HARDNESS(col) (col.a)
#define FULL_HEIGHT(col) ((TERRAIN_HEIGHT(col) + WATER_HEIGHT(col)))

#define SUM_COMPS(v) ((v.r + v.g + v.b + v.a))

// Heightmap (R - height, G - water height, B - suspended sediment amount, R - Surface hardness)
RWTexture2D<float4> HeightMap;

// Velocity field (R - velocity x, G - velocity y)
RWTexture2D<float2> VelocityMap;

// Water Flux field (R - left, G - right, B - top, A - bottom)
RWTexture2D<float4> FluxMap;


// Fluid simulation properties
uint _Width;
uint _Height;
float _TimeDelta;
float _Gravity;
float2 _CellSize;
float _PipeArea;
float _PipeLength;

/* Pass 1. Flux field computation */
[NUMTHREADS]
void FluxComputation(uint3 id : SV_DispatchThreadID)
{
	// Sample the heighmap (state map)
    float4 state = CURRENT_SAMPLE(HeightMap);
    float4 stateLeft = LEFT_SAMPLE(HeightMap);
    float4 stateRight = RIGHT_SAMPLE(HeightMap);
    float4 stateTop = TOP_SAMPLE(HeightMap);
    float4 stateBottom = BOTTOM_SAMPLE(HeightMap);

    float waterHeight = WATER_HEIGHT(state);

	// Flow simulation using shallow-water model. Computation of the velocity field and water height changes.
	// Sample flux
    float4 outputFlux = CURRENT_SAMPLE(FluxMap);

	// Overall height difference in each direction
    float4 heightDifference = FULL_HEIGHT(state) - float4(
		FULL_HEIGHT(stateLeft),
		FULL_HEIGHT(stateRight),
		FULL_HEIGHT(stateTop),
		FULL_HEIGHT(stateBottom));

	// Output flux	
    outputFlux = max(0, outputFlux + _TimeDelta * _Gravity * _PipeArea * heightDifference / _PipeLength);

	/*
		Rescale flux
		The total outflow should not exceed the total amount
		of the water in the given cell.If the calculated value is
		larger than the current amount in the given cell, then flux will
		be scaled down with an appropriate factor
	*/
    outputFlux *= min(1, waterHeight * _CellSize.x * _CellSize.y / (SUM_COMPS(outputFlux) * _TimeDelta));

	// Boundaries (uncomment thisif you want water to bounce of boundaries)						
    if (id.x == 0) LDIR(outputFlux) = 0;
    if (id.y == 0) BDIR(outputFlux) = 0;
    if (id.x == _Width - 1) RDIR(outputFlux) = 0;
    if (id.y == _Height - 1) TDIR(outputFlux) = 0;

	// Write new flux to the FluxMap
	CURRENT_SAMPLE(FluxMap) = max(0, outputFlux);
}

/* Pass 2. Applying fluxes to the actual cells and changing weter height */
[NUMTHREADS]
void FluxApply(uint3 id : SV_DispatchThreadID)
{
    float4 state = CURRENT_SAMPLE(HeightMap);
    float4 outputFlux = CURRENT_SAMPLE(FluxMap);
    float4 inputFlux = float4(
		RDIR(LEFT_SAMPLE(FluxMap)),
		LDIR(RIGHT_SAMPLE(FluxMap)),
		BDIR(TOP_SAMPLE(FluxMap)),
		TDIR(BOTTOM_SAMPLE(FluxMap)));
    float waterHeightBefore = WATER_HEIGHT(state);

	// Water surface and velocity field update
	// volume is changing by amount on incoming fluid volume minus outgoing
    float volumeDelta = SUM_COMPS(inputFlux) - SUM_COMPS(outputFlux);

	// Then, we update the water height in the current (x, y) cell:
	WATER_HEIGHT(state) += _TimeDelta * volumeDelta / (_CellSize.x * _CellSize.y);

	// Write new state to the HeightMap
	CURRENT_SAMPLE(HeightMap) = state;

	// Compute new velocity from flux to the VelocityMap
	CURRENT_SAMPLE(VelocityMap) = float2(
		0.5 * (LDIR(inputFlux) - LDIR(outputFlux) + RDIR(outputFlux) - RDIR(inputFlux)),
		0.5 * (BDIR(inputFlux) - BDIR(outputFlux) + TDIR(outputFlux) - TDIR(inputFlux)));
		/// _PipeLength * 0.5 * (waterHeightBefore + WATER_HEIGHT(state));
}