#include "Common.hlsl"

#pragma enable_d3d11_debug_symbols
#pragma kernel addParticleBlock
#pragma kernel updateParticleCountArgment
#pragma kernel scatterParticleData
#pragma kernel updateParticleNarrowCountArgment

RWStructuredBuffer<int> ParticleCountArgment_RW;
RWStructuredBuffer<float3> ParticlePosition_RW;
RWStructuredBuffer<float3> ParticleVelocity_RW;

StructuredBuffer<float3> TargetParticlePosition_R;
StructuredBuffer<float3> TargetParticleVelocity_R;

RWStructuredBuffer<float3> NarrowParticlePosition_RW;
RWStructuredBuffer<float3> NarrowParticleVelocity_RW;

RWStructuredBuffer<uint> ParticleFilter_RW;
StructuredBuffer<uint> ParticleScatterOffset_R;

float3 WaterGeneratePos;
uint WaterBlockResX;
uint WaterBlockResY;
uint WaterBlockResZ;
uint AddedParticleCount;
uint MaxParticleCount;
float ParticleRadius;

[numthreads(SPH_THREAD_NUM, 1, 1)]
void addParticleBlock(uint ThreadIdx : SV_GroupIndex, uint GroupIdx : SV_GroupID)
{
    int CurrParticleCount = ParticleCountArgment_RW[ParticleCountArgumentOffset];
    uint i = ThreadIdx + GroupIdx * SPH_THREAD_NUM;
    if (i >= AddedParticleCount || CurrParticleCount + i >= MaxParticleCount)
        return;
    
    uint z = i / (WaterBlockResX * WaterBlockResY);
    uint xp = i % (WaterBlockResX * WaterBlockResY);
    uint y = xp / WaterBlockResX;
    uint x = xp % WaterBlockResX;
    ParticlePosition_RW[CurrParticleCount + i] = WaterGeneratePos + float3(x, y, z) * ParticleRadius * 2.0f;
    ParticleVelocity_RW[CurrParticleCount + i] = float3(0, 0, 0);
    ParticleFilter_RW[CurrParticleCount + i] = 1;

}

[numthreads(1, 1, 1)]
void updateParticleCountArgment(uint ThreadIdx : SV_GroupIndex, uint GroupIdx : SV_GroupID)
{
    int CurrParticleCount = ParticleCountArgment_RW[ParticleCountArgumentOffset];
    int NewParticleCount =
            MaxParticleCount <= (CurrParticleCount + (int) AddedParticleCount) ? MaxParticleCount : CurrParticleCount + (int) AddedParticleCount;
    ParticleCountArgment_RW[ParticleCountArgumentOffset] = NewParticleCount;
    ParticleCountArgment_RW[ParticleXGridCountArgumentOffset] = (int) ceil((float) NewParticleCount / SPH_THREAD_NUM);
}

[numthreads(SPH_THREAD_NUM, 1, 1)]
void scatterParticleData(uint ThreadIdx : SV_GroupIndex, uint GroupIdx : SV_GroupID)
{
    uint i = ThreadIdx + GroupIdx * SPH_THREAD_NUM;
    
    uint CurrTargetOffset = ParticleScatterOffset_R[i] - 1;
    uint PrevTargetOffset = i == 0 ? 0 : ParticleScatterOffset_R[i - 1] - 1;
    if (CurrTargetOffset != PrevTargetOffset)
    {
        NarrowParticlePosition_RW[CurrTargetOffset] = TargetParticlePosition_R[i];
        NarrowParticleVelocity_RW[CurrTargetOffset] = TargetParticleVelocity_R[i];
    }
}

[numthreads(1, 1, 1)]
void updateParticleNarrowCountArgment(uint ThreadIdx : SV_GroupIndex, uint GroupIdx : SV_GroupID)
{
    uint i = ParticleCountArgment_RW[ParticleCountArgumentOffset] - 1;
    
    uint CurrTargetOffset = ParticleScatterOffset_R[i] - 1;
    int NewParticleCount = CurrTargetOffset + 1;
    ParticleCountArgment_RW[ParticleCountArgumentOffset] = NewParticleCount;
    ParticleCountArgment_RW[ParticleXGridCountArgumentOffset] = (int) ceil((float) NewParticleCount / SPH_THREAD_NUM);
}